<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
  <title>WebCrypto CSE + KMS</title>
</head>
<body>
  <h3>WebCrypto + æ¨¡æ“¬ KMS å…¬é‘°</h3>
  <button onclick="runDemo()">Run Demo</button>
  <pre id="output"></pre>
  <input type="file" id="fileInput" />
  <script>
    async function runDemo() {
      const output = document.getElementById("output");

      // 1. ç”¢ç”Ÿ AES-GCM å°ç¨±é‡‘é‘°
      const aesKey = await window.crypto.subtle.generateKey(
        { name: "AES-GCM", length: 256 },
        true,
        ["encrypt", "decrypt", "wrapKey"]
      );
      output.textContent += "âœ… AES é‡‘é‘°å·²ç”¢ç”Ÿ\n";

      // è®€å– server (KMS) å…¬é‘°      demoç‰ˆç”±æœ¬åœ°ç”Ÿæˆ
    
      const res = await fetch('/static/public_key.txt');
      output.textContent += "âœ… æˆåŠŸå¾—åˆ°å…¬é‘°\n";
      console.log("æœ‰é€²åˆ° fetch æ®µè½ï¼");
      const pem = await res.text();
      output.textContent += "âœ… test1\n";
      console.log(pem);   

      const pemHeader = "-----BEGIN PUBLIC KEY-----";
      const pemFooter = "-----END PUBLIC KEY-----";

      const pemHeaderIndex = pem.indexOf(pemHeader);
      const pemFooterIndex = pem.indexOf(pemFooter);

      if (pemHeaderIndex === -1 || pemFooterIndex === -1) {
      throw new Error("æ‰¾ä¸åˆ°å…¬é‘° header/footer");
      }
    
        const start = pem.indexOf(pemHeader) + pemHeader.length;
        const end = pem.indexOf(pemFooter);

        let pemContents = pem.substring(start, end);
        pemContents = pemContents.replace(/\s+/g, "");

        console.log("PEM contents (Base64):", pemContents);

      const binaryDerString = window.atob(pemContents);
      output.textContent += "âœ… test1\n";
      const binaryDer = new Uint8Array(binaryDerString.length);
      for (let i = 0; i < binaryDerString.length; i++) {
      binaryDer[i] = binaryDerString.charCodeAt(i);
      }
  
      console.log("Binary DER data:", binaryDer);
      output.textContent += "âœ… test1\n";
      let publicKey;  // ğŸ”µ å®£å‘Šåœ¨å¤–å±¤
  
      try {
      publicKey = await window.crypto.subtle.importKey(
          "spki",
          binaryDer.buffer,
          { name: "RSA-OAEP", hash: "SHA-256" },
          false,
          ["encrypt", "wrapKey"]
      );
      console.log("Public key imported successfully", publicKey);
      } catch (error) {
      console.error("Error importing public key: ", error);
      return; // å¦‚æœåŒ¯å…¥å¤±æ•—ï¼Œæå‰çµæŸ functionï¼Œé¿å…å¾Œé¢é‚„è¦ç”¨
      }
      output.textContent += "âœ… test1\n";
      output.textContent += "âœ… KMS å…¬é‘°åŒ¯å…¥å®Œæˆ\n";

      // 3. å°‡ AES é‡‘é‘°åŠ å¯† (wrap)
      const wrappedKey = await window.crypto.subtle.wrapKey(
        "raw",
        aesKey,
        publicKey,
        { name: "RSA-OAEP" }
      );
      output.textContent += "âœ… AES é‡‘é‘°å·²ç”¨ KMS å…¬é‘°åŒ…è£\n";

        // 4. ç”¨ AES é‡‘é‘°åŠ å¯†è³‡æ–™
        const fileInput = document.getElementById("fileInput");
        const file = fileInput.files[0];

        if (!file) {
            output.textContent += "âŒ è«‹å…ˆé¸æ“‡ä¸€å€‹æª”æ¡ˆ\n";
            return;
        }

        // è®€å–æª”æ¡ˆå…§å®¹
        const reader = new FileReader();
        reader.onload = async function () {
            const fileContent = reader.result; // ArrayBuffer

            // ç”¢ç”Ÿ IV
            const iv = window.crypto.getRandomValues(new Uint8Array(12));
            try {
                // ç”¨ AES é‡‘é‘°åŠ å¯†æª”æ¡ˆå…§å®¹
                const ciphertext = await window.crypto.subtle.encrypt(
                    { name: "AES-GCM", iv: iv },
                    aesKey,
                    fileContent
                );

                output.textContent += "âœ… æª”æ¡ˆå…§å®¹å·²åŠ å¯†\n";

                // åŠ å¯†å®Œæˆå¾Œå°‡ ciphertext è½‰ç‚º Uint8Array
                const ciphertextArray = new Uint8Array(ciphertext);

                // å»ºç«‹ Blob (ç”¨ octet-stream è¡¨ç¤ºäºŒé€²ä½æª”)
                const blob = new Blob([ciphertextArray], { type: "application/octet-stream" });

                // å»ºç«‹ä¸‹è¼‰é€£çµ
                const url = URL.createObjectURL(blob);
                const a = document.createElement("a");
                a.href = url;
                a.download = "encrypted_file.bin";  // æª”æ¡ˆåç¨±ä½ å¯ä»¥è‡ªå·±æ”¹
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);

                // é‡‹æ”¾ URL è³‡æº
                URL.revokeObjectURL(url);

                output.textContent += "âœ… å·²è§¸ç™¼ä¸‹è¼‰åŠ å¯†æª”æ¡ˆ\n";
                
                // â­â­â­ã€è§£å¯†æ®µè½ã€‘â­â­â­
                const decryptedContent = await window.crypto.subtle.decrypt(
                    { name: "AES-GCM", iv: iv },
                    aesKey,
                    ciphertext
                );

                output.textContent += "âœ… å·²æˆåŠŸè§£å¯†æª”æ¡ˆ\n";

                // è§£å¯†å®Œæˆå¾Œå°‡è§£å¯†å…§å®¹è½‰ç‚º Blob (ç”¨åŸæœ¬ type)
                const decryptedBlob = new Blob([decryptedContent], { type: file.type });

                // å»ºç«‹ä¸‹è¼‰é€£çµ (è§£å¯†æª”)
                const decryptedUrl = URL.createObjectURL(decryptedBlob);
                const aDecrypted = document.createElement("a");
                aDecrypted.href = decryptedUrl;
                aDecrypted.download = "decrypted_file" + file.name;  // çµ¦è§£å¯†æª”å‘½å
                document.body.appendChild(aDecrypted);
                aDecrypted.click();
                document.body.removeChild(aDecrypted);
                URL.revokeObjectURL(decryptedUrl);

                output.textContent += "âœ… å·²è§¸ç™¼ä¸‹è¼‰è§£å¯†æª”æ¡ˆ\n";
                
            } catch (error) {
                output.textContent += "âŒ åŠ å¯†éç¨‹ä¸­ç™¼ç”ŸéŒ¯èª¤\n";
                console.error(error);
            }
        };

        // è®€æˆ ArrayBufferï¼ˆæ³¨æ„ï¼é€™è£¡æ˜¯ readAsArrayBufferï¼‰
        reader.readAsArrayBuffer(file);
    }
  </script>
</body>
</html>
