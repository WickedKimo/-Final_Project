<!DOCTYPE html>
<html lang="zh-TW">
<head>
  <meta charset="UTF-8">
  <title>WebCrypto CSE + KMS</title>
  <style>
    body {
      font-family: "Helvetica Neue", sans-serif;
      background-color: #f4f4f4;
      padding: 20px;
      color: #333;
    }
    h3 {
      color: #2c3e50;
    }
    button {
      padding: 10px 20px;
      background-color: #3498db;
      color: white;
      border: none;
      border-radius: 5px;
      cursor: pointer;
      margin-bottom: 10px;
    }
    button:hover {
      background-color: #2980b9;
    }
    #output {
      background-color: #fff;
      border: 1px solid #ccc;
      padding: 10px;
      white-space: pre-wrap;
      margin-top: 10px;
      height: 200px;
      overflow-y: auto;
    }
    input[type="file"] {
      margin-top: 10px;
    }
    .header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 20px;
    }
    .logout-btn {
      padding: 6px 12px;
      font-size: 14px;
      background-color: #e74c3c;
      color: white;
      border: none;
      border-radius: 4px;
      cursor: pointer;
    }
    .logout-btn:hover {
      background-color: #c0392b;
    }
  </style>
</head>

<body>
  <div class="header">
    <div><strong>æ­¡è¿ï¼Œ{{ session['username'] }}ï¼</strong></div>
    <form action="{{ url_for('logout') }}" method="get">
      <button class="logout-btn">ç™»å‡º</button>
    </form>
  </div>

  <h3>WebCrypto + æ¨¡æ“¬ KMS å…¬é‘°</h3>
  <button onclick="runDemo()">Run Demo</button>
  <input type="file" id="fileInput" />
  <pre id="output"></pre>

  <script>
    function base64ToArrayBuffer(base64) {
      const binary = window.atob(base64);
      const bytes = new Uint8Array(binary.length);
      for (let i = 0; i < binary.length; i++) {
        bytes[i] = binary.charCodeAt(i);
      }
      return bytes.buffer;
    }

    async function getPrivateKeyFromLocalStorage() {
      const privateKeyBase64 = localStorage.getItem("privateKey");
      if (!privateKeyBase64) {
        throw new Error("æ‰¾ä¸åˆ° localStorage çš„ privateKey");
      }

      const privateKeyBuffer = base64ToArrayBuffer(privateKeyBase64);

      const privateKey = await window.crypto.subtle.importKey(
        "pkcs8",
        privateKeyBuffer,
        {
          name: "RSASSA-PKCS1-v1_5",
          hash: "SHA-256",
        },
        true,
        ["sign"]
      );

      return privateKey;
    }
    async function runDemo() {
      const output = document.getElementById("output");
      const privateKey = await getPrivateKeyFromLocalStorage();
      console.log("Private Key æ˜¯ï¼š", privateKey);

      const aesKey = await window.crypto.subtle.generateKey(
        { name: "AES-GCM", length: 256 },
        true,
        ["encrypt", "decrypt", "wrapKey"]
      );
      output.textContent += "âœ… AES é‡‘é‘°å·²ç”¢ç”Ÿ\n";

      const message = new TextEncoder().encode("I want KMS public key");
      const signature = await window.crypto.subtle.sign(
        { name: "RSASSA-PKCS1-v1_5", hash: "SHA-256" },
        privateKey,
        message
      );
      output.textContent += "âœ… æˆåŠŸç°½ç½²è«‹æ±‚\n";
      console.log("ç°½ç« çµæœï¼š", new Uint8Array(signature));

      // 2. æŠŠç°½ç« è·Ÿè«‹æ±‚é€åˆ°ä¼ºæœå™¨
      const res = await fetch('/get_kms_key', {
        method: 'POST',
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({
          signature: Array.from(new Uint8Array(signature)),
          message: "I want KMS public key"
        })
      });

      // 3. ä¼ºæœå™¨é©—è­‰é€šéæ‰å›å‚³å…¬é‘°
      //const pem = await res.text();
      const result = await res.json();
      if (result.success) {
        console.log("âœ… ç°½ç« é©—è­‰æˆåŠŸï¼");
        console.log("KMS å…¬é‘°æ˜¯ï¼š", result.kms_public_key);
      } else {
        console.log("message", message)
        console.log("signature base64", btoa(String.fromCharCode(...new Uint8Array(signature))))
        console.error("âŒ é©—è­‰å¤±æ•—ï¼š", result.error);
      }
      const pem = result.kms_public_key;
      output.textContent += "âœ… test1\n";
  


      const pemHeader = "-----BEGIN PUBLIC KEY-----";
      const pemFooter = "-----END PUBLIC KEY-----";

      const pemHeaderIndex = pem.indexOf(pemHeader);
      const pemFooterIndex = pem.indexOf(pemFooter);

      if (pemHeaderIndex === -1 || pemFooterIndex === -1) {
        throw new Error("æ‰¾ä¸åˆ°å…¬é‘° header/footer");
      }
    
      const start = pem.indexOf(pemHeader) + pemHeader.length;
      const end = pem.indexOf(pemFooter);

      let pemContents = pem.substring(start, end);
      pemContents = pemContents.replace(/\s+/g, "");
      console.log("PEM contents (Base64):", pemContents);

      const binaryDerString = window.atob(pemContents);
      output.textContent += "âœ… test1\n";
      const binaryDer = new Uint8Array(binaryDerString.length);
      for (let i = 0; i < binaryDerString.length; i++) {
        binaryDer[i] = binaryDerString.charCodeAt(i);
      }
  
      console.log("Binary DER data:", binaryDer);
      output.textContent += "âœ… test1\n";
      let publicKey;
  
      try {
        publicKey = await window.crypto.subtle.importKey(
          "spki",
          binaryDer.buffer,
          { name: "RSA-OAEP", hash: "SHA-256" },
          false,
          ["encrypt", "wrapKey"]
        );
        console.log("Public key imported successfully", publicKey);
      } catch (error) {
        console.error("Error importing public key: ", error);
        return;
      }
      output.textContent += "âœ… æ”¶åˆ°ä¸¦åŒ¯å…¥ KMS å…¬é‘°\n";
      output.textContent += "âœ… KMS å…¬é‘°åŒ¯å…¥å®Œæˆ\n";

      const wrappedKey = await window.crypto.subtle.wrapKey(
        "raw",
        aesKey,
        publicKey,
        { name: "RSA-OAEP" }
      );
      output.textContent += "âœ… AES é‡‘é‘°å·²ç”¨ KMS å…¬é‘°åŒ…è£\n";

      const fileInput = document.getElementById("fileInput");
      const file = fileInput.files[0];

      if (!file) {
        output.textContent += "âŒ è«‹å…ˆé¸æ“‡ä¸€å€‹æª”æ¡ˆ\n";
        return;
      }

      const reader = new FileReader();
      reader.onload = async function () {
        const fileContent = reader.result;
        const iv = window.crypto.getRandomValues(new Uint8Array(12));

        try {
          const ciphertext = await window.crypto.subtle.encrypt(
            { name: "AES-GCM", iv: iv },
            aesKey,
            fileContent
          );

          output.textContent += "âœ… æª”æ¡ˆå…§å®¹å·²åŠ å¯†\n";

          const data = {
            filename: file.name,
            enc_file_content: Array.from(new Uint8Array(ciphertext)),
            enc_data_key: Array.from(new Uint8Array(wrappedKey)),
            nonce: Array.from(iv)
          };

          const response = await fetch("/upload", {
            method: "POST",
            headers: {
              "Content-Type": "application/json"
            },
            body: JSON.stringify(data)
          });

          const result = await response.json();

          if (result.success) {
            output.textContent += "âœ… ä¸Šå‚³æˆåŠŸï¼\n";
            location.reload();
          } else {
            alert(result.error);  // â† è·³å‡ºæª”åé‡è¤‡éŒ¯èª¤æç¤º
            
          }

        } catch (error) {
          output.textContent += "âŒ åŠ å¯†éç¨‹ä¸­ç™¼ç”ŸéŒ¯èª¤\n";
          console.error(error);
        }
      };

      reader.readAsArrayBuffer(file);
    }

    async function downloadFile(filename) {

      const output = document.getElementById("output");
      const privateKey = await getPrivateKeyFromLocalStorage();
      console.log("Private Key æ˜¯ï¼š", privateKey);

      const message = new TextEncoder().encode("I want new wrapped key");
      const signature = await window.crypto.subtle.sign(
        { name: "RSASSA-PKCS1-v1_5", hash: "SHA-256" },
        privateKey,
        message
      );
      output.textContent += "âœ… æˆåŠŸç°½ç½²è«‹æ±‚\n";
      console.log("ç°½ç« çµæœï¼š", new Uint8Array(signature));

      output.textContent = "æ­£åœ¨æº–å‚™ä¸‹è¼‰æ–‡ä»¶...\n";
      try {
        // 1. ç™¼é€è«‹æ±‚åˆ°å¾Œç«¯å–å¾—åŠ å¯†æª”æ¡ˆã€è¢« RSA åŒ…è£çš„ AES é‡‘é‘° å’Œ IV
        const res = await fetch(`/download/${filename}`, {
          method: 'POST',
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({
            signature: Array.from(new Uint8Array(signature)),
            message: "I want new wrapped key"
          })
        });
        if (!res.ok) {
          throw new Error(`ä¼ºæœå™¨éŒ¯èª¤ï¼š${res.status}`);
        }

        const response = await res.json();

        const encryptedFileBase64 = response.content;
        const encryptedAesKeyBase64 = response.encrypted_private;
        const ivBase64 = response.nonce;

        // 2. è½‰æ›ç‚º ArrayBuffer
        const encryptedFile = Uint8Array.from(atob(encryptedFileBase64), c => c.charCodeAt(0)).buffer;
        const encryptedAesKey = Uint8Array.from(atob(encryptedAesKeyBase64), c => c.charCodeAt(0)).buffer;
        const iv = Uint8Array.from(atob(ivBase64), c => c.charCodeAt(0));

        output.textContent += "ğŸ“¦ åŠ å¯†è³‡æ–™è¼‰å…¥æˆåŠŸ\n";

        // 3. åŒ¯å…¥ä½¿ç”¨è€…ç§é‘°
        const privateKey = await getPrivateKeyFromLocalStorage();

        // 4. è§£é–‹ AES é‡‘é‘°
        const aesKey = await window.crypto.subtle.unwrapKey(
          "raw",                  // è§£åŒ…å¾Œçš„æ ¼å¼
          encryptedAesKey,        // è¢«åŒ…è£çš„ key
          privateKey,       // RSA ç§é‘°
          {
            name: "RSA-OAEP"
          },
          {
            name: "AES-GCM",
            length: 256
          },
          true,
          ["decrypt"]
        );

        output.textContent += "ğŸ”‘ AES é‡‘é‘°æˆåŠŸè§£å°\n";

        // 5. ç”¨ AES è§£å¯†æª”æ¡ˆ
        const decryptedContent = await window.crypto.subtle.decrypt(
          {
            name: "AES-GCM",
            iv: iv
          },
          aesKey,
          encryptedFile
        );

        output.textContent += "âœ… æª”æ¡ˆè§£å¯†æˆåŠŸ\n";

        // 6. ä¸‹è¼‰è§£å¯†å¾Œçš„æª”æ¡ˆ
        const blob = new Blob([decryptedContent]);
        const url = URL.createObjectURL(blob);
        const a = document.createElement("a");
        a.href = url;
        a.download = filename; // ä¿ç•™åŸæª”å
        a.click();
        URL.revokeObjectURL(url);

        output.textContent += "ğŸ“¥ æª”æ¡ˆå·²ä¸‹è¼‰\n";

      } catch (error) {
        output.textContent += `âŒ ä¸‹è¼‰å¤±æ•—: ${error.message}\n`;
        console.error(error);
      }
    }
    


    async function importPrivateKey(pem) {
      const pemHeader = "-----BEGIN PRIVATE KEY-----";
      const pemFooter = "-----END PRIVATE KEY-----";
      
      const pemContents = pem.substring(
        pem.indexOf(pemHeader) + pemHeader.length,
        pem.indexOf(pemFooter)
      ).replace(/\s+/g, '');
      
      const binaryDerString = window.atob(pemContents);
      const binaryDer = new Uint8Array(binaryDerString.length);
      for (let i = 0; i < binaryDerString.length; i++) {
        binaryDer[i] = binaryDerString.charCodeAt(i);
      }
      
      return await window.crypto.subtle.importKey(
        "pkcs8",
        binaryDer,
        { name: "RSA-OAEP", hash: "SHA-256" },
        false,
        ["unwrapKey"]
      );
    }


  </script>
</body>
<table>
  {% for file in files %}
    <tr>
      <td>{{ file.filename }}</td>
      <td>
        <button onclick="downloadFile('{{ file.filename }}')">ä¸‹è¼‰</button>
      </td>
    </tr>
  {% endfor %}
</table>
</html>
