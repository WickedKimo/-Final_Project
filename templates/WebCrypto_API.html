<!DOCTYPE html>
<html lang="zh-TW">
<head>
  <meta charset="UTF-8">
  <title>WebCrypto CSE + KMS</title>
  <style>
    body {
      font-family: "Helvetica Neue", sans-serif;
      background-color: #f4f4f4;
      padding: 20px;
      color: #333;
    }
    h3 {
      color: #2c3e50;
    }
    button {
      padding: 10px 20px;
      background-color: #3498db;
      color: white;
      border: none;
      border-radius: 5px;
      cursor: pointer;
      margin-bottom: 10px;
    }
    button:hover {
      background-color: #2980b9;
    }
    #output {
      background-color: #fff;
      border: 1px solid #ccc;
      padding: 10px;
      white-space: pre-wrap;
      margin-top: 10px;
      height: 200px;
      overflow-y: auto;
    }
    input[type="file"] {
      margin-top: 10px;
    }
    .header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 20px;
    }
    .logout-btn {
      padding: 6px 12px;
      font-size: 14px;
      background-color: #e74c3c;
      color: white;
      border: none;
      border-radius: 4px;
      cursor: pointer;
    }
    .logout-btn:hover {
      background-color: #c0392b;
    }
  </style>
</head>

<body>
  <div class="header">
    <div><strong>æ­¡è¿ï¼Œ{{ session['username'] }}ï¼</strong></div>
    <form action="{{ url_for('logout') }}" method="get">
      <button class="logout-btn">ç™»å‡º</button>
    </form>
  </div>

  <h3>WebCrypto + æ¨¡æ“¬ KMS å…¬é‘°</h3>
  <button onclick="runDemo()">ä¸Šå‚³</button>
  <input type="file" id="fileInput" />
  <pre id="output"></pre>

  <script>
    function base64ToArrayBuffer(base64) {
      const binary = window.atob(base64);
      const bytes = new Uint8Array(binary.length);
      for (let i = 0; i < binary.length; i++) {
        bytes[i] = binary.charCodeAt(i);
      }
      return bytes.buffer;
    }

    async function getPrivateKeysFromLocalStorage() {
      const privateKeyBase64 = localStorage.getItem("privateKey");
      if (!privateKeyBase64) {
        throw new Error("æ‰¾ä¸åˆ° localStorage çš„ privateKey");
      }

      const privateKeyBuffer = base64ToArrayBuffer(privateKeyBase64);

      // ç”¨æ–¼ç°½ç« çš„ private key
      const privateKeySign = await window.crypto.subtle.importKey(
        "pkcs8",
        privateKeyBuffer,
        {
          name: "RSASSA-PKCS1-v1_5",
          hash: "SHA-256",
        },
        true,
        ["sign"]
      );

      // ç”¨æ–¼è§£åŒ… AES key çš„ private key
      const privateKeyUnwrap = await window.crypto.subtle.importKey(
        "pkcs8",
        privateKeyBuffer,
        {
          name: "RSA-OAEP",
          hash: "SHA-256",
        },
        true,
        ["unwrapKey"]
      );

      return { privateKeySign, privateKeyUnwrap };
    }

    async function runDemo() {
      const output = document.getElementById("output");
      try {
        const { privateKeySign } = await getPrivateKeysFromLocalStorage();
        console.log("Private Key æ˜¯ï¼š", privateKeySign);

        const aesKey = await window.crypto.subtle.generateKey(
          { name: "AES-GCM", length: 256 },
          true,
          ["encrypt", "decrypt", "wrapKey"]
        );
        output.textContent += "âœ… AES é‡‘é‘°å·²ç”¢ç”Ÿ\n";

        const message = new TextEncoder().encode("I want KMS public key");
        const signature = await window.crypto.subtle.sign(
          { name: "RSASSA-PKCS1-v1_5", hash: "SHA-256" },
          privateKeySign,
          message
        );
        output.textContent += "âœ… æˆåŠŸç°½ç½²è«‹æ±‚\n";
        console.log("ç°½ç« çµæœï¼š", new Uint8Array(signature));

        const res = await fetch('/get_kms_key', {
          method: 'POST',
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({
            signature: Array.from(new Uint8Array(signature)),
            message: "I want KMS public key"
          })
        });

        const result = await res.json();
        if (!result.success) {
          console.error("âŒ é©—è­‰å¤±æ•—ï¼š", result.error);
          output.textContent += "âŒ é©—è­‰å¤±æ•—\n";
          return;
        }

        console.log("âœ… ç°½ç« é©—è­‰æˆåŠŸï¼");
        console.log("KMS å…¬é‘°æ˜¯ï¼š", result.kms_public_key);

        const pem = result.kms_public_key;
        output.textContent += "âœ… æ”¶åˆ° KMS å…¬é‘°\n";

        // å®‰å…¨è§£æ PEM
        const pemHeader = "-----BEGIN PUBLIC KEY-----";
        const pemFooter = "-----END PUBLIC KEY-----";

        const pemHeaderIndex = pem.indexOf(pemHeader);
        const pemFooterIndex = pem.indexOf(pemFooter);

        if (pemHeaderIndex === -1 || pemFooterIndex === -1) {
          throw new Error("æ‰¾ä¸åˆ°å…¬é‘° header/footer");
        }

        const start = pemHeaderIndex + pemHeader.length;
        const end = pemFooterIndex;
        let pemContents = pem.substring(start, end);
        pemContents = pemContents.replace(/\s+/g, "");
        console.log("PEM contents (Base64):", pemContents);

        // Base64 decode to Uint8Array
        function base64ToUint8Array(base64) {
          const binaryString = window.atob(base64);
          const len = binaryString.length;
          const bytes = new Uint8Array(len);
          for (let i = 0; i < len; i++) {
            bytes[i] = binaryString.charCodeAt(i);
          }
          return bytes;
        }
        const binaryDer = base64ToUint8Array(pemContents);

        console.log("Binary DER data:", binaryDer);
        output.textContent += "âœ… PEM è½‰æ›å®Œæˆ\n";

        let publicKey;
        try {
          publicKey = await window.crypto.subtle.importKey(
            "spki",
            binaryDer.buffer,
            { name: "RSA-OAEP", hash: "SHA-256" },
            false,
            ["encrypt", "wrapKey"]
          );
          console.log("Public key imported successfully", publicKey);
        } catch (error) {
          console.error("Error importing public key: ", error);
          output.textContent += "âŒ åŒ¯å…¥å…¬é‘°å¤±æ•—\n";
          return;
        }
        output.textContent += "âœ… æ”¶åˆ°ä¸¦åŒ¯å…¥ KMS å…¬é‘°\n";

        const wrappedKey = await window.crypto.subtle.wrapKey(
          "raw",
          aesKey,
          publicKey,
          { name: "RSA-OAEP" }
        );
        output.textContent += "âœ… AES é‡‘é‘°å·²ç”¨ KMS å…¬é‘°åŒ…è£\n";

        const fileInput = document.getElementById("fileInput");
        const file = fileInput.files[0];
        if (!file) {
          output.textContent += "âŒ è«‹å…ˆé¸æ“‡ä¸€å€‹æª”æ¡ˆ\n";
          return;
        }

        const reader = new FileReader();
        reader.onload = async function () {
          const fileContent = reader.result;
          const iv = window.crypto.getRandomValues(new Uint8Array(12));

          try {
            const ciphertext = await window.crypto.subtle.encrypt(
              { name: "AES-GCM", iv: iv },
              aesKey,
              fileContent
            );

            output.textContent += "âœ… æª”æ¡ˆå…§å®¹å·²åŠ å¯†\n";

            // å®‰å…¨çš„ Base64 encode å‡½å¼ï¼Œé¿å…çˆ†å †ç–Š
            function toBase64(arr) {
              let binary = "";
              const len = arr.length;
              for (let i = 0; i < len; i++) {
                binary += String.fromCharCode(arr[i]);
              }
              return btoa(binary);
            }

            const data = {
              filename: file.name,
              enc_file_content: toBase64(new Uint8Array(ciphertext)),
              enc_data_key: toBase64(new Uint8Array(wrappedKey)),
              nonce: toBase64(iv)
            };

            const response = await fetch("/upload", {
              method: "POST",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify(data)
            });

            const result = await response.json();
            if (result.success) {
              output.textContent += "âœ… ä¸Šå‚³æˆåŠŸï¼\n";
              location.reload();
            } else {
              alert(result.error);
            }
          } catch (error) {
            output.textContent += "âŒ åŠ å¯†éç¨‹ä¸­ç™¼ç”ŸéŒ¯èª¤\n";
            console.error(error);
          }
        };
        reader.readAsArrayBuffer(file);
      } catch (error) {
        console.error("åŸ·è¡Œ runDemo ç™¼ç”ŸéŒ¯èª¤ï¼š", error);
        output.textContent += `âŒ éŒ¯èª¤ï¼š${error.message}\n`;
      }
    }

    async function downloadFile(filename) {
      const output = document.getElementById("output");
      const { privateKeySign, privateKeyUnwrap } = await getPrivateKeysFromLocalStorage();
      const message = new TextEncoder().encode("I want new wrapped key");
      const signature = await window.crypto.subtle.sign(
        { name: "RSASSA-PKCS1-v1_5", hash: "SHA-256" },
        privateKeySign,
        message
      );
      output.textContent += "âœ… æˆåŠŸç°½ç½²è«‹æ±‚\n";
      console.log("ç°½ç« çµæœï¼š", new Uint8Array(signature));

      output.textContent = "æ­£åœ¨æº–å‚™ä¸‹è¼‰æ–‡ä»¶...\n";
      try {
        // 1. ç™¼é€è«‹æ±‚åˆ°å¾Œç«¯å–å¾—åŠ å¯†æª”æ¡ˆã€è¢« RSA åŒ…è£çš„ AES é‡‘é‘° å’Œ IV
        const res = await fetch(`/download/${filename}`, {
          method: 'POST',
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({
            signature: Array.from(new Uint8Array(signature)),
            message: "I want new wrapped key"
          })
        });
        if (!res.ok) {
          throw new Error(`ä¼ºæœå™¨éŒ¯èª¤ï¼š${res.status}`);
        }

        const response = await res.json();

        const encryptedFileBase64 = response.content;
        const encryptedAesKeyBase64 = response.encrypted_private;
        const ivBase64 = response.nonce;

        // 2. è½‰æ›ç‚º ArrayBuffer
        const encryptedFile = Uint8Array.from(atob(encryptedFileBase64), c => c.charCodeAt(0)).buffer;
        const encryptedAesKey = Uint8Array.from(atob(encryptedAesKeyBase64), c => c.charCodeAt(0)).buffer;
        const iv = Uint8Array.from(atob(ivBase64), c => c.charCodeAt(0));

        output.textContent += "ğŸ“¦ åŠ å¯†è³‡æ–™è¼‰å…¥æˆåŠŸ\n";

        // 3. åŒ¯å…¥ä½¿ç”¨è€…ç§é‘°
        const privateKey = await getPrivateKeysFromLocalStorage();

        // 4. è§£é–‹ AES é‡‘é‘°
        const aesKey = await window.crypto.subtle.unwrapKey(
          "raw",                  // è§£åŒ…å¾Œçš„æ ¼å¼
          encryptedAesKey,        // è¢«åŒ…è£çš„ key
          privateKeyUnwrap,       // RSA ç§é‘°
          {
            name: "RSA-OAEP"
          },
          {
            name: "AES-GCM",
            length: 256
          },
          true,
          ["decrypt"]
        );

        output.textContent += "ğŸ”‘ AES é‡‘é‘°æˆåŠŸè§£å°\n";

        // 5. ç”¨ AES è§£å¯†æª”æ¡ˆ
        const decryptedContent = await window.crypto.subtle.decrypt(
          {
            name: "AES-GCM",
            iv: iv
          },
          aesKey,
          encryptedFile
        );

        output.textContent += "âœ… æª”æ¡ˆè§£å¯†æˆåŠŸ\n";

        // 6. ä¸‹è¼‰è§£å¯†å¾Œçš„æª”æ¡ˆ
        const blob = new Blob([decryptedContent]);
        const url = URL.createObjectURL(blob);
        const a = document.createElement("a");
        a.href = url;
        a.download = filename; // ä¿ç•™åŸæª”å
        a.click();
        URL.revokeObjectURL(url);

        output.textContent += "ğŸ“¥ æª”æ¡ˆå·²ä¸‹è¼‰\n";

      } catch (error) {
        output.textContent += `âŒ ä¸‹è¼‰å¤±æ•—: ${error.message}\n`;
        console.error(error);
      }
    }
    
    async function importPrivateKey(pem) {
      const pemHeader = "-----BEGIN PRIVATE KEY-----";
      const pemFooter = "-----END PRIVATE KEY-----";
      
      const pemContents = pem.substring(
        pem.indexOf(pemHeader) + pemHeader.length,
        pem.indexOf(pemFooter)
      ).replace(/\s+/g, '');
      
      const binaryDerString = window.atob(pemContents);
      const binaryDer = new Uint8Array(binaryDerString.length);
      for (let i = 0; i < binaryDerString.length; i++) {
        binaryDer[i] = binaryDerString.charCodeAt(i);
      }
      
      return await window.crypto.subtle.importKey(
        "pkcs8",
        binaryDer,
        { name: "RSA-OAEP", hash: "SHA-256" },
        false,
        ["unwrapKey"]
      );
    }


  </script>
</body>
<table>
  {% for file in files %}
    <tr>
      <td>{{ file.filename }}</td>
      <td>
        <button onclick="downloadFile('{{ file.filename }}')">ä¸‹è¼‰</button>
      </td>
    </tr>
  {% endfor %}
</table>
</html>
